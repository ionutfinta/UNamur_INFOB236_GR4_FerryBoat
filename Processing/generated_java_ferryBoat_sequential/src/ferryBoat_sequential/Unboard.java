package ferryBoat_sequential; 

import eventb_prelude.*;
import Util.Utilities;

public class Unboard{
	/*@ spec_public */ private fifthRef machine; // reference to the machine 

	/*@ public normal_behavior
		requires true;
		assignable \everything;
		ensures this.machine == m; */
	public Unboard(fifthRef m) {
		this.machine = m;
	}
	
	// Returns the minimal slot possible for the vehicle on the lift's platform... 0 if no place possible.
	private int getMinSlot(int queue, int vehicle_type) {
		for(int i = 1; i <= machine.lift_depth - machine.vehicle_slot.apply(vehicle_type); i++) {
			if(machine.get_lift_vehicles().domain().has(new Pair<Integer, Integer>(queue, i)))
				continue;
			return i;
		}
		return 0;
	}

	/*@ public normal_behavior
		requires true;
 		assignable \nothing;
		ensures \result <==> (machine.VEHICLE_TYPES.has(vehicle_type) && (machine.vehicle_slot.apply(vehicle_type)).compareTo(machine.get_busy_slots()) <= 0 && (new Integer(machine.get_bs_m() + machine.vehicle_slot.apply(vehicle_type))).compareTo(machine.max_bs_m) <= 0 && machine.get_lift_level().equals(new Integer(1)) && (machine.vehicle_slot.apply(vehicle_type)).compareTo(machine.get_bs_p().apply(machine.get_lift_level())) <= 0 && machine.get_reservations().domain().difference(new BSet<Integer>(new Integer(0))).has(vehicle_id) && new Integer(new JMLObjectSet {Integer fInteger v | (exists Integer e; (machine.floors.has(f) && v.equals(vehicle_type)); e.equals(new Pair<Integer,Integer>(f,v)))}).has(machine.get_reservations().apply(vehicle_id)) && machine.get_boarded_ids().has(vehicle_id) && new Enumerated(new Integer(1),machine.queues).has(position_q) && ((machine.get_id_is_left().apply(vehicle_id).equals(true)) ==> (position_q.equals(new Integer(1)))) && ((machine.get_id_is_left().apply(vehicle_id).equals(false)) ==> (position_q.equals(new Integer(2)))) && new Enumerated(machine.vehicle_slot.apply(vehicle_type),machine.lift_depth).has(position_s) && position_s.equals((new BSet<Integer>(new Integer(0)).union(new Integer(new JMLObjectSet {Integer x | (\exists Integer e; (new Enumerated(new Integer(1),machine.lift_depth).has(x) && (x).compareTo((new BSet<Integer>(machine.lift_depth).union(new Integer(new JMLObjectSet {Integer y | (\exists Integer e; (new Enumerated(new Integer(1),machine.lift_depth).has(y) && machine.get_lift_vehicles().domain().has(new Pair<Integer,Integer>(position_q,y))); e.equals(y))}))).min()) <= 0); e.equals(x))}))).max()) && machine.get_lift_out().equals(true) && ((machine.get_lift_level().equals(new Integer(1))) ==> (machine.get_lvl_1_access().equals(true))) && ((machine.get_lift_level().equals(new Integer(2))) ==> (machine.get_lvl_2_access().equals(true))) && ((machine.get_lift_level().equals(new Integer(3))) ==> (machine.get_lvl_3_access().equals(true))) && machine.get_Sensor_state().apply(machine.get_lift_level()).equals(machine.Detecting)); */
	public /*@ pure */ boolean guard_Unboard( Integer vehicle_id, Integer vehicle_type, Integer position_q, Integer position_s) {
		return (machine.VEHICLE_TYPES.has(vehicle_type) && //grd2_2
				(machine.vehicle_slot.apply(vehicle_type)).compareTo(machine.get_busy_slots()) <= 0 && //grd_3_2 
				(new Integer(machine.get_bs_m() + machine.vehicle_slot.apply(vehicle_type))).compareTo(machine.max_bs_m) <= 0 && //grd4_2 
				machine.get_lift_level().equals(new Integer(1)) && //grd5_2
				(machine.vehicle_slot.apply(vehicle_type)).compareTo(machine.get_bs_p().apply(machine.get_lift_level())) <= 0 && //grd6_2 
				machine.get_reservations().domain().difference(new BSet<Integer>(new Integer(0))).has(vehicle_id) && //grd7_2
				//grd8_2 had no sense in Event-B (same as previous one 7_2)
				machine.get_boarded_ids().has(vehicle_id) && //grd1_3
				new Enumerated(new Integer(1),machine.queues).has(position_q) && //grd2_3 
				BOOL.implication(machine.get_id_is_left().apply(vehicle_id).equals(true),position_q.equals(new Integer(1))) && //grd3_3 
				BOOL.implication(machine.get_id_is_left().apply(vehicle_id).equals(false),position_q.equals(new Integer(2))) && //same
				new Enumerated(machine.vehicle_slot.apply(vehicle_type),machine.lift_depth).has(position_s) &&  //grd4_3
				//grd5_3 generated by `true &&`. Let's use a function:
				position_s.equals(getMinSlot(position_q, vehicle_type)) &&
				machine.get_lift_out().equals(true) && //grd1
				BOOL.implication(machine.get_lift_level().equals(new Integer(1)),machine.get_lvl_1_access().equals(true)) && //grd2 
				BOOL.implication(machine.get_lift_level().equals(new Integer(2)),machine.get_lvl_2_access().equals(true)) && //grd3
				BOOL.implication(machine.get_lift_level().equals(new Integer(3)),machine.get_lvl_3_access().equals(true)) && //grd4
				machine.get_Sensor_state().apply(machine.get_lift_level()).equals(machine.Detecting)); //grd1_5
	}

	/*@ public normal_behavior
		requires guard_Unboard(vehicle_id,vehicle_type,position_q,position_s);
		assignable machine.busy_slots, machine.bs_m, machine.bs_p, machine.in_lift_ids, machine.boarded_ids, machine.lift_vehicles;
		ensures guard_Unboard(vehicle_id,vehicle_type,position_q,position_s) &&  machine.get_busy_slots() == \old(new Integer(machine.get_busy_slots() - machine.vehicle_slot.apply(vehicle_type))) &&  machine.get_bs_m() == \old(new Integer(machine.get_bs_m() + machine.vehicle_slot.apply(vehicle_type))) &&  machine.get_bs_p().equals(\old((machine.get_bs_p().override(new BRelation<Integer,Integer>(new Pair<Integer,Integer>(machine.get_lift_level(),new Integer(machine.get_bs_p().apply(machine.get_lift_level()) - machine.vehicle_slot.apply(vehicle_type)))))))) &&  machine.get_in_lift_ids().equals(\old((machine.get_in_lift_ids().union(new BSet<Integer>(vehicle_id))))) &&  machine.get_boarded_ids().equals(\old(machine.get_boarded_ids().difference(new BSet<Integer>(vehicle_id)))) &&  machine.get_lift_vehicles().equals(\old((machine.get_lift_vehicles().union(new BRelation<Pair<Integer,Integer>,Integer>(new JMLObjectSet {Pair<Integer,Integer> x | (\exists BRelation<Pair<Integer,Integer>,Integer> e; (BRelation.cross(new BSet<Integer>(position_q),new Enumerated(new Integer(new Integer(position_s - machine.vehicle_slot.apply(vehicle_type)) + 1),position_s)).has(null)); e.equals(new Pair<Integer,ERROR>(null,vehicle_id)))}))))); 
	 also
		requires !guard_Unboard(vehicle_id,vehicle_type,position_q,position_s);
		assignable \nothing;
		ensures true; */
	public void run_Unboard( Integer vehicle_id, Integer vehicle_type, Integer position_q, Integer position_s){
		if(guard_Unboard(vehicle_id,vehicle_type,position_q,position_s)) {
			Integer busy_slots_tmp = machine.get_busy_slots();
			Integer bs_m_tmp = machine.get_bs_m();
			BRelation<Integer,Integer> bs_p_tmp = machine.get_bs_p();
			BSet<Integer> in_lift_ids_tmp = machine.get_in_lift_ids();
			BSet<Integer> boarded_ids_tmp = machine.get_boarded_ids();
			BRelation<Pair<Integer,Integer>,Integer> lift_vehicles_tmp = machine.get_lift_vehicles();

			machine.set_busy_slots(new Integer(busy_slots_tmp - machine.vehicle_slot.apply(vehicle_type)));
			machine.set_bs_m(new Integer(bs_m_tmp + machine.vehicle_slot.apply(vehicle_type)));
			machine.set_bs_p((bs_p_tmp.override(new BRelation<Integer,Integer>(new Pair<Integer,Integer>(machine.get_lift_level(),new Integer(bs_p_tmp.apply(machine.get_lift_level()) - machine.vehicle_slot.apply(vehicle_type)))))));
			machine.set_in_lift_ids((in_lift_ids_tmp.union(new BSet<Integer>(vehicle_id))));
			machine.set_boarded_ids(boarded_ids_tmp.difference(new BSet<Integer>(vehicle_id)));
			// La génération par défaut pose problème:
			//machine.set_lift_vehicles((lift_vehicles_tmp.union(new BRelation<Pair<Integer,Integer>,Integer>(new JMLObjectSet {Pair<Integer,Integer> x | (\exists BRelation<Pair<Integer,Integer>,Integer> e; (BRelation.cross(new BSet<Integer>(position_q),new Enumerated(new Integer(new Integer(position_s - machine.vehicle_slot.apply(vehicle_type)) + 1),position_s)).has(null)); e.equals(new Pair<Integer,ERROR>(null,vehicle_id)))}))));
			// On la redéfinit comme suit:
			lift_vehicles_tmp.insert(new Pair<Integer, Integer>(position_q, position_s), vehicle_id);
			machine.set_lift_vehicles(lift_vehicles_tmp);

			
			System.out.println("Unboard executed vehicle_id: " + vehicle_id + " vehicle_type: " + vehicle_type + " position_q: " + position_q + " position_s: " + position_s + " ");
		}
	}

}
